/// <reference types="react" />
declare module "sabre-ngv-core/modules/IModuleManifest" {
    export interface IModuleManifest {
        name: string;
        meta?: {
            [key: string]: any;
        };
        dependencies?: string[];
        url?: string;
    }
}
declare module "sabre-ngv-core/modules/ExposedClassesStruct" {
    import { Class } from "sabre-ngv-app/_types";
    export interface ExposedClassesStruct {
        [key: string]: ExposedClassesStruct | Class<any> | Function;
    }
}
declare module "sabre-ngv-core/modules/IModule" {
    import { IModuleManifest } from "sabre-ngv-core/modules/IModuleManifest";
    import { ExposedClassesStruct } from "sabre-ngv-core/modules/ExposedClassesStruct";
    export interface IModule {
        init(): void;
        getManifest(): IModuleManifest;
        getName(): string;
        getMeta(key: string): any;
        getExposedClasses(): ExposedClassesStruct;
    }
}
declare module "sabre-ngv-core/modules/IModuleContext" {
    import { IModule } from "sabre-ngv-core/modules/IModule";
    import { Command } from 'sabre-ngv-app/app/common/data/dto/Command';
    import { CommandFlow } from 'sabre-ngv-app/app/common/data/dto/CommandFlow';
    import { NgvServiceClass, NgvServiceType } from 'sabre-ngv-app/_types';
    import { AbstractServiceOptions } from 'sabre-ngv-app/app/services/impl/AbstractServiceOptions';
    import { AbstractService } from 'sabre-ngv-app/app/services/impl/AbstractService';
    export interface IModuleContext {
        setModule(module: IModule): void;
        getModule(): IModule;
        getModuleName(): string;
        cf(command: Command): CommandFlow;
        registerService<T extends AbstractService>(serviceClass: NgvServiceClass<T>, options?: AbstractServiceOptions): void;
        getService<T extends AbstractService>(serviceClass: NgvServiceType<T>): T;
    }
}
declare module "sabre-ngv-core/helpers/ProxyContext" {
    export const proxyContext: <T extends Object>(target: T, context: {
        [key: string]: Object;
    }) => T;
}
declare module "sabre-ngv-core/modules/ModuleContext" {
    import { IModuleContext } from "sabre-ngv-core/modules/IModuleContext";
    import { IModule } from "sabre-ngv-core/modules/IModule";
    import { Command } from "sabre-ngv-app/app/common/data/dto/Command";
    import { CommandFlow } from "sabre-ngv-app/app/common/data/dto/CommandFlow";
    import { NgvServiceClass, NgvServiceType } from "sabre-ngv-app/_types";
    import { AbstractServiceOptions } from "sabre-ngv-app/app/services/impl/AbstractServiceOptions";
    import { AbstractService } from "sabre-ngv-app/app/services/impl/AbstractService";
    export class ModuleContext implements IModuleContext {
        private moduleName;
        private static MODULE_CONTEXTS;
        private static CONTEXTUAL_INSTANCES;
        private module;
        private requestFactory;
        constructor(moduleName?: string);
        setModule(module: IModule): void;
        getModule(): IModule;
        getModuleName(): string;
        cf(command: Command): CommandFlow;
        private decorateCommandFlow(commandFlow);
        registerService<T extends AbstractService>(serviceClass: NgvServiceClass<T>, options?: AbstractServiceOptions): void;
        getService<T extends AbstractService>(serviceClass: NgvServiceType<T>): T;
        private getRequestFactoryService();
        static getContexts(target: object): IModuleContext[];
        static addContext(target: object, context: IModuleContext): void;
        static copyContexts(giver: object, taker: object): void;
        static hasContext(target: object, context: IModuleContext): boolean;
    }
}
declare module "sabre-ngv-core/helpers/PrototypeExtension" {
    export interface PrototypeExtension {
        [key: string]: any;
    }
}
declare module "sabre-ngv-core/helpers/PrototypeExtender" {
    import { AbstractClass } from "sabre-ngv-app/_types";
    import { PrototypeExtension } from "sabre-ngv-core/helpers/PrototypeExtension";
    /**
     *
     *  Low level helper class for merging prototypes
     *
     */
    export class PrototypeExtender {
        private prototypeExtension;
        constructor(prototypeExtension: PrototypeExtension);
        extend(target: AbstractClass): void;
    }
}
declare module "sabre-ngv-core/modules/Module" {
    import { IModuleManifest } from "sabre-ngv-core/modules/IModuleManifest";
    import { IModule } from "sabre-ngv-core/modules/IModule";
    import { ExposedClassesStruct } from "sabre-ngv-core/modules/ExposedClassesStruct";
    export abstract class Module implements IModule {
        private manifest;
        /**
         * Module object constructor. Requires manifest describing module.
         *
         * @param manifest Module manifest
         */
        constructor(manifest: IModuleManifest);
        /**
         * Module initialization method.
         *
         * Overwrite it in sub-classes to provide module initialization. For example you may contribute to drawer configuration.
         */
        init(): void;
        /**
         * Returns module manifest.
         *
         * @returns Module manifest
         */
        getManifest(): IModuleManifest;
        /**
         * Returns module name.
         *
         * @returns Module name
         */
        getName(): string;
        getMeta(key: string): any;
        getExposedClasses(): ExposedClassesStruct;
    }
}
declare module "sabre-ngv-core/services/ILayerService" {
    import { ModalOptions } from "sabre-ngv-app/app/widgets/layer/views/ModalOptions";
    import { LayerOptions } from "sabre-ngv-app/app/widgets/layer/views/LayerOptions";
    import { AbstractView } from "sabre-ngv-app/app/AbstractView";
    import { ViewDescriptor } from "sabre-ngv-app/_types";
    import { Layer } from "sabre-ngv-app/app/widgets/layer/views/Layer";
    import { JsonObject } from "sabre-ngv-app/_types";
    import { ComponentType } from "react";
    /**
     * LayerService interface
     */
    export abstract class ILayerService {
        static SERVICE_NAME: 'layer';
        /**
         * Shows given widget in modal window.
         *
         * @param widget - Widget to be shown
         * @param modalOptions - Modal panel configuration options
         * @param layerOptions - customisation how and where the modal should be displayed
         */
        abstract showInModal(widget: Object, modalOptions?: ModalOptions, layerOptions?: any): void;
        /**
         * Shows given widget on the top of the layer with overlay
         * @param widget - widget to be shown
         * @param layerOptions - customisation how and where the widget should be displayed
         */
        abstract showOnLayer(widget: ViewDescriptor | AbstractView | ComponentType, layerOptions?: LayerOptions, componentProps?: JsonObject): void;
        abstract clearLayer(position?: number): void;
        abstract getLayers(): Map<number, Layer>;
        abstract getLayer(position: number): Layer;
    }
}
declare module "sabre-ngv-core/services/LayerService" {
    import { ILayerService } from "sabre-ngv-core/services/ILayerService";
    import { ModalOptions } from "sabre-ngv-app/app/widgets/layer/views/ModalOptions";
    import { AbstractService } from "sabre-ngv-app/app/services/impl/AbstractService";
    import { Layer } from "sabre-ngv-app/app/widgets/layer/views/Layer";
    import { ViewDescriptor } from "sabre-ngv-app/_types";
    import { LayerOptions } from "sabre-ngv-app/app/widgets/layer/views/LayerOptions";
    import { AbstractView } from "sabre-ngv-app/app/AbstractView";
    import { JsonObject, LayerWidget } from "sabre-ngv-app/_types";
    /**
     * Layer service allows access to view layer, which displays modals.
     */
    export class LayerService extends AbstractService implements ILayerService {
        static SERVICE_NAME: 'layer';
        private static DEFAULT_LAYER_POSITION;
        private layers;
        private createLayer(position?);
        private insertRecentlyAddedLayerToDom(layer);
        private getFirstLayer();
        /**
         * @inheritDoc
         */
        showInModal(widget: ViewDescriptor | AbstractView, modalOptions?: ModalOptions, layerOptions?: LayerOptions): void;
        /**
         * Converts widget to C2W if widget is React Component, otherwise do nothing
         */
        private convertWidgetForLayer(widget, componentProps?);
        /**
         * @inheritDoc
         */
        showOnLayer(widget: LayerWidget, layerOptions?: LayerOptions, componentProps?: JsonObject): void;
        /**
         * @inheritDoc
         */
        putOnLayer(widget: LayerWidget, layerOptions?: LayerOptions, componentProps?: JsonObject): void;
        /**
         * @inheritDoc
         */
        clearLayer(position?: number): void;
        /**
         * @inheritDoc
         */
        getLayers(): Map<number, Layer>;
        /**
         * @inheritDoc
         */
        getLayer(position?: number): Layer;
        private onDataReceived(data);
    }
}
declare module "sabre-ngv-core/configs/drawer/LargeWidgetDrawerConfig" {
    import { ILargeWidgetDrawerConfig, LargeWidgetDrawerConfigType } from "sabre-ngv-app/app/services/impl/ILargeWidgetDrawerConfig";
    import { ViewDescriptor } from "sabre-ngv-app/_types";
    import { ModalOptions } from "sabre-ngv-app/app/widgets/layer/views/ModalOptions";
    import { AbstractView } from "sabre-ngv-app/app/AbstractView";
    /**
     * Drawer's large widget configuration class.
     *
     * Large widgets are displayed in modal window when user clicks on tile in drawer.
     *
     * @param <T> - interface of tile class
     * @param <U> - interface of large widget class
     */
    export class LargeWidgetDrawerConfig<T extends AbstractView, U extends AbstractView> implements ILargeWidgetDrawerConfig<T, U> {
        type: LargeWidgetDrawerConfigType;
        tile: ViewDescriptor<T>;
        widget: ViewDescriptor<U>;
        modalOptions?: ModalOptions;
        /**
         * Constructor.
         *
         * @param tile - descriptor of widget to be displayed as tile
         * @param widget - descriptoy of widget to be displayed as large widget
         * @param modalOptions - options for modal holding large widget
         */
        constructor(tile: ViewDescriptor<T>, widget: ViewDescriptor<U>, modalOptions?: ModalOptions);
    }
}
declare module "sabre-ngv-core/configs/drawer/SmallWidgetDrawerConfig" {
    import { ISmallWidgetDrawerConfig, SmallWidgetDrawerConfigType } from "sabre-ngv-app/app/services/impl/ISmallWidgetDrawerConfig";
    import { ViewDescriptor } from "sabre-ngv-app/_types";
    import { AbstractView } from "sabre-ngv-app/app/AbstractView";
    /**
     * Drawer's small widget configuration class.
     *
     * Small widgets are displayed inlined in drawer when user clicks on tile.
     *
     * @param <T> - interface of tile class
     * @param <U> - interface of small widget class
     */
    export class SmallWidgetDrawerConfig<T extends AbstractView, U extends AbstractView> implements ISmallWidgetDrawerConfig<T, U> {
        type: SmallWidgetDrawerConfigType;
        tile: ViewDescriptor<T>;
        widget: ViewDescriptor<U>;
        /**
         * Constructor.
         *
         * @param tile - descriptor of widget to be displayed as tile
         * @param widget - descriptoy of widget to be displayed as small widget (inlined)
         */
        constructor(tile: ViewDescriptor<T>, widget: ViewDescriptor<U>);
    }
}
declare module "sabre-ngv-core/configs/drawer/TileWidgetDrawerConfig" {
    import { ITileWidgetDrawerConfig, TileWidgetDrawerConfigType } from "sabre-ngv-app/app/services/impl/ITileWidgetDrawerConfig";
    import { ViewDescriptor } from "sabre-ngv-app/_types";
    import { AbstractView } from "sabre-ngv-app/app/AbstractView";
    /**
     * Drawer's tile widget configuration class.
     *
     * Tile widgets are just tiles with some quick detailed information.
     *
     * @param <T> - interface of tile class
     */
    export class TileWidgetDrawerConfig<T extends AbstractView> implements ITileWidgetDrawerConfig<T> {
        type: TileWidgetDrawerConfigType;
        tile: ViewDescriptor<T>;
        /**
         * Constructor.
         *
         * @param tile - descriptor of widget to be displayed as tile
         */
        constructor(tile: ViewDescriptor<T>);
    }
}
declare module "sabre-ngv-core/decorators/classes/Initial" {
    import { AbstractClass, NgvInitOptions } from "sabre-ngv-app/_types";
    /**
     * Decorator used to initialize object with passed attribute values.
     *
     * It is used to make TS inheritance system compatible with Backbone one.
     * Configures object when the one is being constructed before constructor method is called.
     * Available configuration options are described by interface passed as type parameter.
     *
     * @param <T> - interface of attributes to be initialized
     * @param initialOptions - attributes to be initialized
     *
     * @example
     * \@Initial<SomeModelOptions>({
     *   autoPropagateData: true
     * })
     * export class SomeClass {
     * }
     */
    export function Initial<T extends NgvInitOptions>(initialOptions: T): (target: AbstractClass) => void;
}
declare module "sabre-ngv-core/decorators/classes/Mixin" {
    import { AbstractClass } from "sabre-ngv-app/_types";
    import { PrototypeExtension } from "sabre-ngv-core/helpers/PrototypeExtension";
    /**
     * Mixin decorator, used to add a mixin to a class.
     *
     * Concept of mixins was used widely in Backbone-based application,
     * but it turned out it is too hard to understand for programmers,
     * so please use mixins only for backward compatibility and re-using
     * already implemented functionalities.
     *
     * @param mixin - Mixin class to be added
     *
     * @example
     * \@Mixin(WithSomeMixin)
     * export class SomeClass {
     *   // ...
     * }
     */
    export function Mixin(mixin: PrototypeExtension): (target: AbstractClass) => void;
}
declare module "sabre-ngv-core/decorators/methods/Bound" {
    export function Bound(target: {
        [key: string]: any;
    }, methodName: string): void;
}
declare module "sabre-ngv-core/decorators/classes/view/CssClass" {
    import { NgvViewClass } from "sabre-ngv-app/_types";
    /**
     * Options for the CssClass decorator.
     */
    export interface CssClassDecoratorOptions {
        /**
         * Flag indicating if CSS class passed should overwrite current ones.
         *
         * By default CSS class is merged with current ones.
         */
        overwrite?: boolean;
    }
    /**
     * Decorator which allows to set or overwrite css class of given widget class.
     *
     * @param cssClassName - name of the CSS class
     * @param options - options used when setting CSS class to widget
     *
     * @example
     * \@CssClass('drawer profile-search-drawer')
     * export class SomeViewClass {
     *   // ...
     * }
     */
    export function CssClass(cssClassName: string, options?: CssClassDecoratorOptions): (target: NgvViewClass) => void;
}
declare module "sabre-ngv-core/decorators/classes/view/Template" {
    import { NgvViewClass } from "sabre-ngv-app/_types";
    /**
     * Decorator to bind template to a widget.
     *
     * @param templateName - Name of the template in format: `module-name:template-name`
     *
     * @example
     * \@Template('sabre-sdk-sample-drawer:SampleDrawerView')
     * export class SomeViewClass {
     *   // ...
     * }
     */
    export function Template(templateName: string): (target: NgvViewClass) => void;
}
declare module "sabre-ngv-core/decorators/methods/domEvents/OnDomEvent" {
    export type DomEventName = 'click' | 'tap' | string;
    /**
     *  A decorator function for attaching methods as event listeners. Mainly used by other decorators, not by itself.
     *
     * @param eventName - Event name or an array of event names
     * @param selector - Element selector
     * @param args - arguments passed to the method when it's triggered
     * @constructor
     */
    export function OnDomEvent(eventName: DomEventName | Array<DomEventName>, selector?: string, args?: Array<any>): (target: {
        [key: string]: any;
    }, methodName: string) => void;
}
declare module "sabre-ngv-core/decorators/methods/domEvents/OnChange" {
    /**
     * Decorator used to attach a method as a change event listener.
     *
     * @param selector - Selector for the element to trigger the change event
     * @param args - Arguments to pass to the listener method on execution
     *
     * @example
     * \@OnChange('.select')
     * private handleSelectChange() {
     * }
     */
    export function OnChange(selector?: string, args?: Array<any>): (target: {
        [key: string]: any;
    }, methodName: string) => void;
}
declare module "sabre-ngv-core/decorators/methods/domEvents/OnClick" {
    /**
     * Decorator used to attach a method as a click event listener.
     *
     * @param selector - Selector for the element to trigger the click event
     * @param args - Arguments to pass to the listener method on execution
     *
     * @example
     * \@OnClick('.button')
     * private handleButtonClick() {
     * }
     */
    export function OnClick(selector?: string, args?: Array<any>): (target: {
        [key: string]: any;
    }, methodName: string) => void;
}
declare module "sabre-ngv-core/decorators/methods/domEvents/OnKeyCombo" {
    /**
     * Decorator used to attach a method as a keydown event listener.
     *
     * @param combo - Name of the key or key combination
     * @param selector - Selector for the element to trigger the keydown event
     * @param args - Arguments to pass to the listener method on execution
     *
     * @example
     * \@OnKeyDown('alt+up', '.input')
     * private handleInputAltUp() {
     * }
     */
    export function OnKeyCombo(combo: string, selector?: string, args?: Array<any>): (target: {
        [key: string]: any;
    }, methodName: string) => void;
}
